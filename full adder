EXPERIMENT-3 
1. Full Adder:

Logic code:

`timescale 1ns / 1ps
module fullAdder(
    input [1:0] A, [1:0] B, 
    output [1:0] sum,
    output Cout

    );
    wire c0;
    
    assign sum[0] = A[0]^B[0];
    assign c0=A[0]&B[0];
    assign sum[1]= A[1]^B[1]^c0;
    assign Cout=A[1]&B[1] | (A[1]^B[1])&c0;
endmodule



Testbench code:

`timescale 1ns / 1ps
module fullAdder_tb(

    );
    reg [1:0] A; 
    reg [1:0] B;
    wire [1:0] sum;
    wire Cout;
    
    fullAdder dut(
        .A(A),
        .B(B),
        .sum(sum),
        .Cout(Cout)
        );
    reg clk,rst;  
    always begin
       clk=~clk; #10;
    end
    initial begin
       clk=0;
       rst=1;
       #10 rst=0;
    end
    integer i;
    initial i=0;
    always@(posedge clk) begin
        if(!rst) begin
            A = $random % 4;
            B = $random % 4;
            i=i+1;
            if(i==10) $finish;
      

  end
  end    
  initial begin 
        $display("Time | A   B |    sum  Cout");
        $monitor("%4dns |  %b  %b | %b   %B", $time, A,     B, sum, Cout);
    end
endmodule
